{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "toast-button",
  "type": "registry:block",
  "title": "Toast Button",
  "description": "An upload button component which uses toasts as its response method",
  "dependencies": [
    "lucide-react@^0.435.0",
    "@paralleldrive/cuid2@^2.2.2",
    "uploadthing@^7.7.2",
    "@uploadthing/react@^7.3.1",
    "@uploadthing/shared@^7.1.8",
    "@radix-ui/react-slot",
    "class-variance-authority",
    "clsx",
    "tailwind-merge",
    ".",
    "lucide-react",
    "@uploadthing/react",
    "uploadthing",
    "@upstash/redis",
    "@upstash/ratelimit",
    "@uploadthing/shared",
    "sonner",
    "zustand",
    "@paralleldrive/cuid2"
  ],
  "registryDependencies": [
    "sonner",
    "button"
  ],
  "files": [
    {
      "path": "registry/new-york/toast-button/toast-button.tsx",
      "content": "\"use client\";\r\n\r\nimport ActionButton from \"@/components/uploadthingui/common/action-button\";\r\nimport ButtonDetails from \"@/components/uploadthingui/common/button-details\";\r\nimport { UploadButton, useUploadThing } from \"@/lib/uploadthing\";\r\nimport {\r\n  checkFileObjectKey,\r\n  getFileSizeFormatted,\r\n  truncateFileName,\r\n} from \"@/lib/uploadthingui-utils\";\r\nimport { useFileStorageStore, UTUIFile } from \"@/stores/main\";\r\nimport { createId } from \"@paralleldrive/cuid2\";\r\nimport { useEffect, useRef, type ComponentProps } from \"react\";\r\nimport { toast } from \"sonner\";\r\nimport { generatePermittedFileTypes } from \"uploadthing/client\";\r\n\r\n// Get the props type directly from UploadButton\r\ntype UploadButtonProps = ComponentProps<typeof UploadButton>;\r\n\r\n/**\r\n * @description An upload button component which uses toasts as its response method.\r\n * @param {UploadButtonProps} props - The props for the UploadButton component.\r\n * @param {boolean} showDetails - Whether to show the details of the upload.\r\n * @param {string} instanceId - The instance ID for the upload. Required to avoid multiple instances of the same component if multiple upload buttons are used.\r\n * @param {boolean} allowInBetweenUploads - Whether to allow in between uploads.\r\n * @param {routeDetails} routeDetails - Additional details for the upload; Example: maxFileCount, minFileCount, etc.\r\n * @param {React.ReactNode} children - React node to render a custom button component.\r\n */\r\nexport default function ToastButton({\r\n  props,\r\n  showDetails = false,\r\n  instanceId,\r\n  allowInBetweenUploads = true,\r\n  routeDetails,\r\n  children,\r\n}: {\r\n  props: UploadButtonProps;\r\n  showDetails?: boolean;\r\n  instanceId: string;\r\n  routeDetails?: {\r\n    maxFileCount?: number;\r\n    minFileCount?: number;\r\n  };\r\n  allowInBetweenUploads?: boolean;\r\n  children?: React.ReactNode;\r\n}) {\r\n  // [1]. States, Refs, Hooks, etc.\r\n  const { endpoint, ...restProps } = props;\r\n\r\n  // Used to reference the file input element\r\n  const fileInputRef = useRef<HTMLInputElement>(null);\r\n\r\n  const { getFiles, addFiles } = useFileStorageStore();\r\n\r\n  // Used to get the route config from uploadthing\r\n  const { routeConfig } = useUploadThing(endpoint, {\r\n    ...restProps,\r\n  });\r\n\r\n  const files = getFiles(instanceId);\r\n\r\n  const canUpload =\r\n    allowInBetweenUploads ||\r\n    files.filter((file) => file.status === \"uploading\").length === 0;\r\n\r\n  // Used to generate the accepted file types\r\n  const acceptedFileTypes = generatePermittedFileTypes(routeConfig)\r\n    .fileTypes.map((fileType) => {\r\n      if (fileType.includes(\"/\")) {\r\n        return fileType;\r\n      } else {\r\n        return `${fileType}/*`;\r\n      }\r\n    })\r\n    .join(\",\");\r\n\r\n  // Used to check the file route options\r\n  const fileRouteOptions = checkFileObjectKey({\r\n    str: generatePermittedFileTypes(routeConfig).fileTypes[0],\r\n    obj: routeConfig,\r\n  });\r\n\r\n  // If the file route options are not found then return\r\n  if (!fileRouteOptions) return;\r\n\r\n  // [2]. Handlers\r\n  // Used to open the file input prompt\r\n  const handleFileButtonClick = () => {\r\n    fileInputRef.current?.click();\r\n  };\r\n\r\n  // Used to handle the file change event\r\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const selectedFiles = e.target.files;\r\n\r\n    // If no files are selected then return\r\n    if (!selectedFiles || selectedFiles.length === 0) return;\r\n\r\n    if (!canUpload) return;\r\n\r\n    // At this moment, the files are not uploaded, so we set the status to \"not started\"\r\n    addFiles(\r\n      instanceId,\r\n      Array.from(selectedFiles).map((fileObj) => ({\r\n        id: createId(),\r\n        file: fileObj,\r\n        status: \"not started\",\r\n        createdAt: new Date(),\r\n      })),\r\n      routeDetails ?? {}\r\n    );\r\n\r\n    // Reset the input to allow selection of the same files again\r\n    if (fileInputRef.current) {\r\n      fileInputRef.current.value = \"\";\r\n    }\r\n  };\r\n\r\n  // [3]. JSX\r\n  return (\r\n    <main className=\"flex min-h-screen flex-col items-center justify-between p-24\">\r\n      <div className=\"flex\">\r\n        {/* Hidden input to allow selection of files */}\r\n        <input\r\n          ref={fileInputRef}\r\n          type=\"file\"\r\n          className=\"hidden\"\r\n          multiple={\r\n            routeDetails?.maxFileCount === undefined ||\r\n            routeDetails.maxFileCount > 1\r\n          }\r\n          accept={acceptedFileTypes}\r\n          onChange={handleFileChange}\r\n        />\r\n        <div className=\"flex flex-col items-center gap-4\">\r\n          <ActionButton\r\n            children={children}\r\n            handleFileButtonClick={handleFileButtonClick}\r\n            disabled={!canUpload}\r\n          />\r\n          {showDetails && (\r\n            <ButtonDetails\r\n              acceptedFileTypes={acceptedFileTypes}\r\n              maxFileCount={routeDetails?.maxFileCount ?? 0}\r\n              minFileCount={routeDetails?.minFileCount ?? 0}\r\n              maxFileSize={fileRouteOptions.maxFileSize}\r\n            />\r\n          )}\r\n        </div>\r\n      </div>\r\n      {/* Uploading toasts */}\r\n      {files.map((file) => (\r\n        <UploadingToast\r\n          key={file.id}\r\n          file={file}\r\n          props={props}\r\n          instanceId={instanceId}\r\n        />\r\n      ))}\r\n    </main>\r\n  );\r\n}\r\n\r\n/**\r\n * @description A component that displays the uploading toast.\r\n * @param {UTUIFile} file - The file to upload.\r\n * @param {UploadButtonProps} props - The props for the UploadButton component.\r\n * @param {string} instanceId - The instance ID for the upload. Required to avoid multiple instances of the same component if multiple upload buttons are used.\r\n */\r\nfunction UploadingToast({\r\n  file,\r\n  props,\r\n  instanceId,\r\n}: {\r\n  file: UTUIFile;\r\n  props: UploadButtonProps;\r\n  instanceId: string;\r\n}) {\r\n  // [1]. States, Refs, Hooks, etc.\r\n  const { endpoint, ...restProps } = props;\r\n\r\n  const fileUploadRef = useRef(false);\r\n\r\n  // Used to create an abort controller\r\n  const abortControllerRef = useRef<AbortController | null>(\r\n    new AbortController()\r\n  );\r\n\r\n  const { removeFiles, updateFile, getFiles } = useFileStorageStore();\r\n\r\n  // Used to start the upload\r\n  const { startUpload } = useUploadThing(endpoint, {\r\n    ...restProps,\r\n    // Set the upload progress granularity to \"fine\" if not provided\r\n    uploadProgressGranularity: restProps.uploadProgressGranularity ?? \"fine\",\r\n    signal: abortControllerRef.current?.signal,\r\n    onUploadError: (error) => {\r\n      // Run the onUploadError prop if provided\r\n      restProps.onUploadError?.(error);\r\n\r\n      // Update the file status to \"error\" and set the error message\r\n      updateFile(instanceId, {\r\n        ...file,\r\n        status: \"error\",\r\n        error: error.message,\r\n      });\r\n\r\n      // Throw the error to be caught by the toast\r\n      throw new Error(error.message);\r\n    },\r\n    onBeforeUploadBegin: (files) => {\r\n      // Run the onUploadBegin prop if provided\r\n      restProps?.onUploadBegin?.(file.file.name);\r\n\r\n      // Update the file status to \"uploading\"\r\n      updateFile(instanceId, { ...file, status: \"uploading\" });\r\n\r\n      return files;\r\n    },\r\n    onClientUploadComplete: (res) => {\r\n      // Run the onClientUploadComplete prop if provided\r\n      restProps?.onClientUploadComplete?.(res);\r\n\r\n      // Update the file status to \"uploaded\"\r\n      updateFile(instanceId, { ...file, status: \"uploaded\" });\r\n    },\r\n  });\r\n\r\n  // [2]. Effects\r\n  // This effect will only then start the upload to avoid rerendering / reuploading the same files\r\n  useEffect(() => {\r\n    if (!fileUploadRef.current && file.status === \"not started\") {\r\n      // Set the file upload ref to true to avoid reuploading the same file\r\n      fileUploadRef.current = true;\r\n\r\n      // Start the upload\r\n      const fileUploadPromise = startUpload([file.file]);\r\n\r\n      // Render the toast\r\n      toast.promise(fileUploadPromise, {\r\n        loading: (\r\n          <div className=\"flex flex-col\">\r\n            <p>Uploading...</p>\r\n            <p>\r\n              {truncateFileName(file.file.name)} (\r\n              {getFileSizeFormatted(file.file.size)})\r\n            </p>\r\n          </div>\r\n        ),\r\n        success: () => {\r\n          // Remove the file from the state to avoid reuploading the same file\r\n          removeFiles(instanceId, file.id);\r\n\r\n          return {\r\n            message: `Uploaded successfully!`,\r\n            description: `${truncateFileName(\r\n              file.file.name\r\n            )} - (${getFileSizeFormatted(file.file.size)})`,\r\n          };\r\n        },\r\n        error: () => {\r\n          const currentFile = getFiles(instanceId).find(\r\n            (f) => f.id === file.id\r\n          );\r\n\r\n          // Remove the file from the state to avoid reuploading the same file\r\n          removeFiles(instanceId, file.id);\r\n\r\n          return {\r\n            message: `${\r\n              currentFile?.error\r\n                ? truncateFileName(currentFile.error, 32)\r\n                : \"Failed to upload!\"\r\n            }`,\r\n            description: `${truncateFileName(\r\n              file.file.name\r\n            )} - (${getFileSizeFormatted(file.file.size)})`,\r\n          };\r\n        },\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => {\r\n            // Remove the file and abort the upload\r\n            abortControllerRef.current?.abort();\r\n            removeFiles(instanceId, file.id);\r\n          },\r\n        },\r\n      });\r\n    }\r\n  }, [file]);\r\n\r\n  // Returning null because the toast is rendered by the useUploadThing hook\r\n  return null;\r\n}\r\n",
      "type": "registry:block",
      "target": "components/uploadthingui/toast-button.tsx"
    },
    {
      "path": "stores/main.ts",
      "content": "import { toast } from \"sonner\";\r\nimport { create } from \"zustand\";\r\n\r\nexport type UTUIFile = {\r\n  file: File;\r\n  id: string;\r\n  status: \"uploading\" | \"uploaded\" | \"not started\" | \"error\";\r\n  error?: string;\r\n  createdAt: Date;\r\n};\r\n\r\ntype additionalDetails = {\r\n  maxFileCount?: number;\r\n  minFileCount?: number;\r\n};\r\n\r\ninterface FileStorageState {\r\n  instances: Record<string, UTUIFile[]>;\r\n  addFiles: (\r\n    instanceId: string,\r\n    files: UTUIFile[],\r\n    additionalDetails: additionalDetails\r\n  ) => void;\r\n  removeFiles: (instanceId: string, fileId: string) => void;\r\n  updateFile: (instanceId: string, file: UTUIFile) => void;\r\n  getFiles: (instanceId: string) => UTUIFile[];\r\n}\r\n\r\nconst defaultFileStorageState = {\r\n  instances: {},\r\n};\r\n\r\nexport const useFileStorageStore = create<FileStorageState>()((set, get) => ({\r\n  ...defaultFileStorageState,\r\n  // Takes an array of files and add them to the state for a specific instance\r\n  addFiles: (\r\n    instanceId: string,\r\n    files: UTUIFile[],\r\n    additionalDetails: additionalDetails\r\n  ) => {\r\n    if (\r\n      additionalDetails.maxFileCount &&\r\n      get().getFiles(instanceId).length + files.length >\r\n        additionalDetails.maxFileCount\r\n    ) {\r\n      toast.error(`Failed to upload!`, {\r\n        description: `Max file count of ${additionalDetails.maxFileCount} exceeded.`,\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => toast.dismiss(),\r\n        },\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (\r\n      additionalDetails.minFileCount &&\r\n      get().getFiles(instanceId).length + files.length <\r\n        additionalDetails.minFileCount\r\n    ) {\r\n      toast.error(`Failed to upload!`, {\r\n        description: `Required to upload at least ${additionalDetails.minFileCount} files.`,\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => toast.dismiss(),\r\n        },\r\n      });\r\n      return;\r\n    }\r\n    return set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: [...(state.instances[instanceId] || []), ...files],\r\n      },\r\n    }));\r\n  },\r\n  // Takes an array of files and remove them from the state for a specific instance\r\n  removeFiles: (instanceId: string, fileId: string) => {\r\n    return set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: (state.instances[instanceId] || []).filter(\r\n          (file) => file.id !== fileId\r\n        ),\r\n      },\r\n    }));\r\n  },\r\n  updateFile: (instanceId: string, file: UTUIFile) =>\r\n    set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: (state.instances[instanceId] || []).map((f) =>\r\n          f.id === file.id ? file : f\r\n        ),\r\n      },\r\n    })),\r\n  getFiles: (instanceId: string) => get().instances[instanceId] || [],\r\n}));\r\n",
      "type": "registry:lib",
      "target": "stores/main.ts"
    },
    {
      "path": "lib/uploadthingui-utils.ts",
      "content": "import { ExpandedRouteConfig, FileRouterInputKey } from \"@uploadthing/shared\";\r\n\r\nexport function getFileSizeFormatted(size: number) {\r\n  if (size < 1024) return `${size} B`;\r\n  if (size < 1024 * 1024) return `${(size / 1024).toFixed(0)} KB`;\r\n  if (size < 1024 * 1024 * 1024) return `${(size / 1024 / 1024).toFixed(1)} MB`;\r\n  return `${(size / 1024 / 1024 / 1024).toFixed(2)} GB`;\r\n}\r\n\r\n// Return the objects value\r\nexport function checkFileObjectKey({\r\n  str,\r\n  obj,\r\n}: {\r\n  str: FileRouterInputKey | undefined;\r\n  obj: ExpandedRouteConfig | undefined;\r\n}) {\r\n  if (!str || !obj) return null;\r\n\r\n  if (obj && typeof obj === \"object\" && obj.hasOwnProperty(str)) {\r\n    return obj[str];\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * @description A utility function that truncates the file name to a maximum number of characters.\r\n * @param {string} fileName - The file name to truncate.\r\n * @param {number} maxChars - The maximum number of characters to truncate the file name to. Default is 24.\r\n * @returns {string} The truncated file name.\r\n */\r\nexport function truncateFileName(fileName: string, maxChars?: number) {\r\n  if (fileName.length > 20) {\r\n    return `${fileName.slice(0, maxChars ?? 24)}...`;\r\n  }\r\n  return fileName;\r\n}\r\n",
      "type": "registry:lib",
      "target": "lib/uploadthingui-utils.ts"
    },
    {
      "path": "lib/uploadthing.ts",
      "content": "import {\r\n  generateUploadButton,\r\n  generateUploadDropzone,\r\n  generateReactHelpers,\r\n} from \"@uploadthing/react\";\r\n\r\nimport { OurFileRouter } from \"@/app/api/uploadthing/core\";\r\n\r\nexport const UploadButton = generateUploadButton<OurFileRouter>();\r\nexport const UploadDropzone = generateUploadDropzone<OurFileRouter>();\r\nexport const { useUploadThing, uploadFiles } =\r\n  generateReactHelpers<OurFileRouter>();\r\n",
      "type": "registry:lib",
      "target": "lib/uploadthing.ts"
    },
    {
      "path": "registry/new-york/common/action-button/action-button.tsx",
      "content": "import { Button } from \"@/components/ui/button\";\r\nimport { Upload } from \"lucide-react\";\r\n\r\n/**\r\n * @description A conditional button component that will render a custom button component if provided, otherwise it will render a default button component.\r\n * @param {function} handleFileButtonClick - Function to handle the file button click event.\r\n * @param {boolean} disabled - Whether to disable the button.\r\n * @param {React.ReactNode} children - React node to render a custom button component.\r\n */\r\nexport default function ActionButton({\r\n  handleFileButtonClick,\r\n  disabled,\r\n  children,\r\n}: {\r\n  handleFileButtonClick: () => void;\r\n  disabled?: boolean;\r\n  children: React.ReactNode;\r\n}) {\r\n  // If a custom button has returned then render that and attach the onClick handler to it\r\n  if (children) {\r\n    return <div onClick={handleFileButtonClick}>{children}</div>;\r\n  }\r\n\r\n  // Otherwise render the default button component\r\n  return (\r\n    <Button\r\n      className=\"w-fit\"\r\n      onClick={handleFileButtonClick}\r\n      disabled={disabled}\r\n    >\r\n      <Upload className=\"w-4 h-4\" />\r\n      <span className=\"ml-2\">Upload</span>\r\n    </Button>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "components/uploadthingui/common/action-button.tsx"
    },
    {
      "path": "registry/new-york/common/button-details/button-details.tsx",
      "content": "/**\r\n * @description A component that displays the details of the upload button.\r\n * @param {string} acceptedFileTypes - The accepted file types.\r\n * @param {number} maxFileCount - The maximum number of files that can be uploaded.\r\n * @param {string} maxFileSize - The maximum file size that can be uploaded.\r\n */\r\nexport default function ButtonDetails({\r\n  acceptedFileTypes,\r\n  maxFileCount,\r\n  maxFileSize,\r\n  minFileCount,\r\n}: {\r\n  acceptedFileTypes: string;\r\n  maxFileCount: number;\r\n  maxFileSize: string;\r\n  minFileCount: number;\r\n}) {\r\n  // [1]. JSX\r\n  return (\r\n    <div className=\"flex gap-2 flex-wrap items-center justify-center text-sm\">\r\n      <span className=\"text-center\">Allowed type: {acceptedFileTypes}</span>\r\n      <span className=\"text-center\">\r\n        Atleast {minFileCount > 1 ? minFileCount : 1} file(s)\r\n      </span>\r\n      {maxFileCount > 0 && (\r\n        <span className=\"text-center\">Atmost {maxFileCount} file(s)</span>\r\n      )}\r\n      <span className=\"text-center\">Up to {maxFileSize} each</span>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "components/uploadthingui/common/button-details.tsx"
    },
    {
      "path": "registry\\new-york\\toast-button\\toast-button.tsx",
      "content": "\"use client\";\r\n\r\nimport ActionButton from \"@/components/uploadthingui/common/action-button\";\r\nimport ButtonDetails from \"@/components/uploadthingui/common/button-details\";\r\nimport { UploadButton, useUploadThing } from \"@/lib/uploadthing\";\r\nimport {\r\n  checkFileObjectKey,\r\n  getFileSizeFormatted,\r\n  truncateFileName,\r\n} from \"@/lib/uploadthingui-utils\";\r\nimport { useFileStorageStore, UTUIFile } from \"@/stores/main\";\r\nimport { createId } from \"@paralleldrive/cuid2\";\r\nimport { useEffect, useRef, type ComponentProps } from \"react\";\r\nimport { toast } from \"sonner\";\r\nimport { generatePermittedFileTypes } from \"uploadthing/client\";\r\n\r\n// Get the props type directly from UploadButton\r\ntype UploadButtonProps = ComponentProps<typeof UploadButton>;\r\n\r\n/**\r\n * @description An upload button component which uses toasts as its response method.\r\n * @param {UploadButtonProps} props - The props for the UploadButton component.\r\n * @param {boolean} showDetails - Whether to show the details of the upload.\r\n * @param {string} instanceId - The instance ID for the upload. Required to avoid multiple instances of the same component if multiple upload buttons are used.\r\n * @param {boolean} allowInBetweenUploads - Whether to allow in between uploads.\r\n * @param {routeDetails} routeDetails - Additional details for the upload; Example: maxFileCount, minFileCount, etc.\r\n * @param {React.ReactNode} children - React node to render a custom button component.\r\n */\r\nexport default function ToastButton({\r\n  props,\r\n  showDetails = false,\r\n  instanceId,\r\n  allowInBetweenUploads = true,\r\n  routeDetails,\r\n  children,\r\n}: {\r\n  props: UploadButtonProps;\r\n  showDetails?: boolean;\r\n  instanceId: string;\r\n  routeDetails?: {\r\n    maxFileCount?: number;\r\n    minFileCount?: number;\r\n  };\r\n  allowInBetweenUploads?: boolean;\r\n  children?: React.ReactNode;\r\n}) {\r\n  // [1]. States, Refs, Hooks, etc.\r\n  const { endpoint, ...restProps } = props;\r\n\r\n  // Used to reference the file input element\r\n  const fileInputRef = useRef<HTMLInputElement>(null);\r\n\r\n  const { getFiles, addFiles } = useFileStorageStore();\r\n\r\n  // Used to get the route config from uploadthing\r\n  const { routeConfig } = useUploadThing(endpoint, {\r\n    ...restProps,\r\n  });\r\n\r\n  const files = getFiles(instanceId);\r\n\r\n  const canUpload =\r\n    allowInBetweenUploads ||\r\n    files.filter((file) => file.status === \"uploading\").length === 0;\r\n\r\n  // Used to generate the accepted file types\r\n  const acceptedFileTypes = generatePermittedFileTypes(routeConfig)\r\n    .fileTypes.map((fileType) => {\r\n      if (fileType.includes(\"/\")) {\r\n        return fileType;\r\n      } else {\r\n        return `${fileType}/*`;\r\n      }\r\n    })\r\n    .join(\",\");\r\n\r\n  // Used to check the file route options\r\n  const fileRouteOptions = checkFileObjectKey({\r\n    str: generatePermittedFileTypes(routeConfig).fileTypes[0],\r\n    obj: routeConfig,\r\n  });\r\n\r\n  // If the file route options are not found then return\r\n  if (!fileRouteOptions) return;\r\n\r\n  // [2]. Handlers\r\n  // Used to open the file input prompt\r\n  const handleFileButtonClick = () => {\r\n    fileInputRef.current?.click();\r\n  };\r\n\r\n  // Used to handle the file change event\r\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const selectedFiles = e.target.files;\r\n\r\n    // If no files are selected then return\r\n    if (!selectedFiles || selectedFiles.length === 0) return;\r\n\r\n    if (!canUpload) return;\r\n\r\n    // At this moment, the files are not uploaded, so we set the status to \"not started\"\r\n    addFiles(\r\n      instanceId,\r\n      Array.from(selectedFiles).map((fileObj) => ({\r\n        id: createId(),\r\n        file: fileObj,\r\n        status: \"not started\",\r\n        createdAt: new Date(),\r\n      })),\r\n      routeDetails ?? {}\r\n    );\r\n\r\n    // Reset the input to allow selection of the same files again\r\n    if (fileInputRef.current) {\r\n      fileInputRef.current.value = \"\";\r\n    }\r\n  };\r\n\r\n  // [3]. JSX\r\n  return (\r\n    <main className=\"flex min-h-screen flex-col items-center justify-between p-24\">\r\n      <div className=\"flex\">\r\n        {/* Hidden input to allow selection of files */}\r\n        <input\r\n          ref={fileInputRef}\r\n          type=\"file\"\r\n          className=\"hidden\"\r\n          multiple={\r\n            routeDetails?.maxFileCount === undefined ||\r\n            routeDetails.maxFileCount > 1\r\n          }\r\n          accept={acceptedFileTypes}\r\n          onChange={handleFileChange}\r\n        />\r\n        <div className=\"flex flex-col items-center gap-4\">\r\n          <ActionButton\r\n            children={children}\r\n            handleFileButtonClick={handleFileButtonClick}\r\n            disabled={!canUpload}\r\n          />\r\n          {showDetails && (\r\n            <ButtonDetails\r\n              acceptedFileTypes={acceptedFileTypes}\r\n              maxFileCount={routeDetails?.maxFileCount ?? 0}\r\n              minFileCount={routeDetails?.minFileCount ?? 0}\r\n              maxFileSize={fileRouteOptions.maxFileSize}\r\n            />\r\n          )}\r\n        </div>\r\n      </div>\r\n      {/* Uploading toasts */}\r\n      {files.map((file) => (\r\n        <UploadingToast\r\n          key={file.id}\r\n          file={file}\r\n          props={props}\r\n          instanceId={instanceId}\r\n        />\r\n      ))}\r\n    </main>\r\n  );\r\n}\r\n\r\n/**\r\n * @description A component that displays the uploading toast.\r\n * @param {UTUIFile} file - The file to upload.\r\n * @param {UploadButtonProps} props - The props for the UploadButton component.\r\n * @param {string} instanceId - The instance ID for the upload. Required to avoid multiple instances of the same component if multiple upload buttons are used.\r\n */\r\nfunction UploadingToast({\r\n  file,\r\n  props,\r\n  instanceId,\r\n}: {\r\n  file: UTUIFile;\r\n  props: UploadButtonProps;\r\n  instanceId: string;\r\n}) {\r\n  // [1]. States, Refs, Hooks, etc.\r\n  const { endpoint, ...restProps } = props;\r\n\r\n  const fileUploadRef = useRef(false);\r\n\r\n  // Used to create an abort controller\r\n  const abortControllerRef = useRef<AbortController | null>(\r\n    new AbortController()\r\n  );\r\n\r\n  const { removeFiles, updateFile, getFiles } = useFileStorageStore();\r\n\r\n  // Used to start the upload\r\n  const { startUpload } = useUploadThing(endpoint, {\r\n    ...restProps,\r\n    // Set the upload progress granularity to \"fine\" if not provided\r\n    uploadProgressGranularity: restProps.uploadProgressGranularity ?? \"fine\",\r\n    signal: abortControllerRef.current?.signal,\r\n    onUploadError: (error) => {\r\n      // Run the onUploadError prop if provided\r\n      restProps.onUploadError?.(error);\r\n\r\n      // Update the file status to \"error\" and set the error message\r\n      updateFile(instanceId, {\r\n        ...file,\r\n        status: \"error\",\r\n        error: error.message,\r\n      });\r\n\r\n      // Throw the error to be caught by the toast\r\n      throw new Error(error.message);\r\n    },\r\n    onBeforeUploadBegin: (files) => {\r\n      // Run the onUploadBegin prop if provided\r\n      restProps?.onUploadBegin?.(file.file.name);\r\n\r\n      // Update the file status to \"uploading\"\r\n      updateFile(instanceId, { ...file, status: \"uploading\" });\r\n\r\n      return files;\r\n    },\r\n    onClientUploadComplete: (res) => {\r\n      // Run the onClientUploadComplete prop if provided\r\n      restProps?.onClientUploadComplete?.(res);\r\n\r\n      // Update the file status to \"uploaded\"\r\n      updateFile(instanceId, { ...file, status: \"uploaded\" });\r\n    },\r\n  });\r\n\r\n  // [2]. Effects\r\n  // This effect will only then start the upload to avoid rerendering / reuploading the same files\r\n  useEffect(() => {\r\n    if (!fileUploadRef.current && file.status === \"not started\") {\r\n      // Set the file upload ref to true to avoid reuploading the same file\r\n      fileUploadRef.current = true;\r\n\r\n      // Start the upload\r\n      const fileUploadPromise = startUpload([file.file]);\r\n\r\n      // Render the toast\r\n      toast.promise(fileUploadPromise, {\r\n        loading: (\r\n          <div className=\"flex flex-col\">\r\n            <p>Uploading...</p>\r\n            <p>\r\n              {truncateFileName(file.file.name)} (\r\n              {getFileSizeFormatted(file.file.size)})\r\n            </p>\r\n          </div>\r\n        ),\r\n        success: () => {\r\n          // Remove the file from the state to avoid reuploading the same file\r\n          removeFiles(instanceId, file.id);\r\n\r\n          return {\r\n            message: `Uploaded successfully!`,\r\n            description: `${truncateFileName(\r\n              file.file.name\r\n            )} - (${getFileSizeFormatted(file.file.size)})`,\r\n          };\r\n        },\r\n        error: () => {\r\n          const currentFile = getFiles(instanceId).find(\r\n            (f) => f.id === file.id\r\n          );\r\n\r\n          // Remove the file from the state to avoid reuploading the same file\r\n          removeFiles(instanceId, file.id);\r\n\r\n          return {\r\n            message: `${\r\n              currentFile?.error\r\n                ? truncateFileName(currentFile.error, 32)\r\n                : \"Failed to upload!\"\r\n            }`,\r\n            description: `${truncateFileName(\r\n              file.file.name\r\n            )} - (${getFileSizeFormatted(file.file.size)})`,\r\n          };\r\n        },\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => {\r\n            // Remove the file and abort the upload\r\n            abortControllerRef.current?.abort();\r\n            removeFiles(instanceId, file.id);\r\n          },\r\n        },\r\n      });\r\n    }\r\n  }, [file]);\r\n\r\n  // Returning null because the toast is rendered by the useUploadThing hook\r\n  return null;\r\n}\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "components\\uploadthingui\\common\\action-button.tsx",
      "content": "import ActionButtonComponent from \"@/registry/new-york/common/action-button/action-button\";\r\n\r\nexport default function ActionButton({\r\n  handleFileButtonClick,\r\n  disabled,\r\n  children,\r\n}: {\r\n  handleFileButtonClick: () => void;\r\n  disabled?: boolean;\r\n  children: React.ReactNode;\r\n}) {\r\n  return (\r\n    <ActionButtonComponent\r\n      handleFileButtonClick={handleFileButtonClick}\r\n      disabled={disabled}\r\n    >\r\n      {children}\r\n    </ActionButtonComponent>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "registry\\new-york\\common\\action-button\\action-button.tsx",
      "content": "import { Button } from \"@/components/ui/button\";\r\nimport { Upload } from \"lucide-react\";\r\n\r\n/**\r\n * @description A conditional button component that will render a custom button component if provided, otherwise it will render a default button component.\r\n * @param {function} handleFileButtonClick - Function to handle the file button click event.\r\n * @param {boolean} disabled - Whether to disable the button.\r\n * @param {React.ReactNode} children - React node to render a custom button component.\r\n */\r\nexport default function ActionButton({\r\n  handleFileButtonClick,\r\n  disabled,\r\n  children,\r\n}: {\r\n  handleFileButtonClick: () => void;\r\n  disabled?: boolean;\r\n  children: React.ReactNode;\r\n}) {\r\n  // If a custom button has returned then render that and attach the onClick handler to it\r\n  if (children) {\r\n    return <div onClick={handleFileButtonClick}>{children}</div>;\r\n  }\r\n\r\n  // Otherwise render the default button component\r\n  return (\r\n    <Button\r\n      className=\"w-fit\"\r\n      onClick={handleFileButtonClick}\r\n      disabled={disabled}\r\n    >\r\n      <Upload className=\"w-4 h-4\" />\r\n      <span className=\"ml-2\">Upload</span>\r\n    </Button>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "components\\ui\\button.tsx",
      "content": "import * as React from \"react\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-9 w-9\",\n        xs: \"h-7 rounded-md px-2\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n);\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean;\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\";\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    );\n  }\n);\nButton.displayName = \"Button\";\n\nexport { Button, buttonVariants };\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib\\utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\nimport { EachRoute, ROUTES } from \"./routes-config\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function helperSearch(\n  query: string,\n  node: EachRoute,\n  prefix: string,\n  currenLevel: number,\n  maxLevel?: number\n) {\n  const res: EachRoute[] = [];\n  let parentHas = false;\n\n  const nextLink = `${prefix}${node.href}`;\n  if (!node.noLink && node.title.toLowerCase().includes(query.toLowerCase())) {\n    res.push({ ...node, items: undefined, href: nextLink });\n    parentHas = true;\n  }\n  const goNext = maxLevel ? currenLevel < maxLevel : true;\n  if (goNext) {\n    node.items?.forEach((item) => {\n      const innerRes = helperSearch(\n        query,\n        item,\n        nextLink,\n        currenLevel + 1,\n        maxLevel\n      );\n      if (!!innerRes.length && !parentHas && !node.noLink) {\n        res.push({ ...node, items: undefined, href: nextLink });\n        parentHas = true;\n      }\n      res.push(...innerRes);\n    });\n  }\n  return res;\n}\n\nexport function advanceSearch(query: string) {\n  return ROUTES.map((node) =>\n    helperSearch(query, node, \"\", 1, query.length == 0 ? 2 : undefined)\n  ).flat();\n}\n\n// Thursday, May 23, 2024\nexport function formatDate(dateStr: string): string {\n  const [day, month, year] = dateStr.split(\"-\").map(Number);\n  const date = new Date(year, month - 1, day);\n\n  const options: Intl.DateTimeFormatOptions = {\n    weekday: \"long\",\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\",\n  };\n\n  return date.toLocaleDateString(\"en-US\", options);\n}\n\n//  May 23, 2024\nexport function formatDate2(dateStr: string): string {\n  const [day, month, year] = dateStr.split(\"-\").map(Number);\n  const date = new Date(year, month - 1, day);\n\n  const options: Intl.DateTimeFormatOptions = {\n    month: \"short\",\n    day: \"numeric\",\n    year: \"numeric\",\n  };\n  return date.toLocaleDateString(\"en-US\", options);\n}\n\nexport function stringToDate(date: string) {\n  const [day, month, year] = date.split(\"-\").map(Number);\n  return new Date(year, month - 1, day);\n}\n\n// https://devicon.dev/\n//  icon format : <i class=\"devicon-go-plain\"></i>\nexport const fileExtensionIconMap = {\n  js: \"javascript\",\n  ts: \"typescript\",\n  jsx: \"react\",\n  tsx: \"react\",\n  java: \"java\",\n  css: \"css3\",\n  md: \"markdown\",\n  mdx: \"markdown\",\n  go: \"go\",\n  astro: \"astro\",\n  prisma: \"prisma\",\n  py: \"python\",\n  kt: \"kotlin\",\n  php: \"php\",\n  gitignore: \"git\",\n  cs: \"csharp\",\n  cpp: \"cplusplus\",\n  c: \"c\",\n  bash: \"bash\",\n  html: \"html5\",\n};\n\nexport function hasSupportedExtension(name: string) {\n  const splittedNames = name.split(\".\");\n  const ext = splittedNames[splittedNames.length - 1];\n  if (!ext) return false;\n  return !!fileExtensionIconMap[ext as keyof typeof fileExtensionIconMap];\n}\n\nexport function getIconName(name: string) {\n  const splittedNames = name.split(\".\");\n  const ext = splittedNames[splittedNames.length - 1];\n  return fileExtensionIconMap[ext as keyof typeof fileExtensionIconMap];\n}\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "components\\uploadthingui\\common\\button-details.tsx",
      "content": "import ButtonDetailsComponent from \"@/registry/new-york/common/button-details/button-details\";\r\n\r\nexport default function ButtonDetails({\r\n  acceptedFileTypes,\r\n  maxFileCount,\r\n  maxFileSize,\r\n  minFileCount,\r\n}: {\r\n  acceptedFileTypes: string;\r\n  maxFileCount: number;\r\n  maxFileSize: string;\r\n  minFileCount: number;\r\n}) {\r\n  return (\r\n    <ButtonDetailsComponent\r\n      acceptedFileTypes={acceptedFileTypes}\r\n      maxFileCount={maxFileCount}\r\n      maxFileSize={maxFileSize}\r\n      minFileCount={minFileCount}\r\n    />\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "registry\\new-york\\common\\button-details\\button-details.tsx",
      "content": "/**\r\n * @description A component that displays the details of the upload button.\r\n * @param {string} acceptedFileTypes - The accepted file types.\r\n * @param {number} maxFileCount - The maximum number of files that can be uploaded.\r\n * @param {string} maxFileSize - The maximum file size that can be uploaded.\r\n */\r\nexport default function ButtonDetails({\r\n  acceptedFileTypes,\r\n  maxFileCount,\r\n  maxFileSize,\r\n  minFileCount,\r\n}: {\r\n  acceptedFileTypes: string;\r\n  maxFileCount: number;\r\n  maxFileSize: string;\r\n  minFileCount: number;\r\n}) {\r\n  // [1]. JSX\r\n  return (\r\n    <div className=\"flex gap-2 flex-wrap items-center justify-center text-sm\">\r\n      <span className=\"text-center\">Allowed type: {acceptedFileTypes}</span>\r\n      <span className=\"text-center\">\r\n        Atleast {minFileCount > 1 ? minFileCount : 1} file(s)\r\n      </span>\r\n      {maxFileCount > 0 && (\r\n        <span className=\"text-center\">Atmost {maxFileCount} file(s)</span>\r\n      )}\r\n      <span className=\"text-center\">Up to {maxFileSize} each</span>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib\\uploadthing.ts",
      "content": "import {\r\n  generateUploadButton,\r\n  generateUploadDropzone,\r\n  generateReactHelpers,\r\n} from \"@uploadthing/react\";\r\n\r\nimport { OurFileRouter } from \"@/app/api/uploadthing/core\";\r\n\r\nexport const UploadButton = generateUploadButton<OurFileRouter>();\r\nexport const UploadDropzone = generateUploadDropzone<OurFileRouter>();\r\nexport const { useUploadThing, uploadFiles } =\r\n  generateReactHelpers<OurFileRouter>();\r\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "app\\api\\uploadthing\\core.ts",
      "content": "import { createUploadthing, type FileRouter } from \"uploadthing/next\";\r\nimport { UploadThingError } from \"uploadthing/server\";\r\nimport { Redis } from \"@upstash/redis\";\r\nimport { Ratelimit } from \"@upstash/ratelimit\";\r\n\r\nconst f = createUploadthing();\r\n\r\nconst redis = new Redis({\r\n  url: process.env.UPSTASH_REDIS_REST_URL,\r\n  token: process.env.UPSTASH_REDIS_REST_TOKEN,\r\n});\r\n\r\nconst rateLimit = new Ratelimit({\r\n  redis,\r\n  limiter: Ratelimit.slidingWindow(6, \"60s\"),\r\n});\r\n\r\nconst rateLimitMiddleware = async (req: Request) => {\r\n  const ip =\r\n    req.headers.get(\"x-real-ip\") ??\r\n    req.headers.get(\"x-forwarded-for\") ??\r\n    \"127.0.0.1\";\r\n\r\n  const { success } = await rateLimit.limit(ip);\r\n\r\n  if (!success) {\r\n    throw new UploadThingError(\"Rate limit exceeded\");\r\n  }\r\n\r\n  // Otherwise, return\r\n  return;\r\n};\r\n\r\n// FileRouter for your app, can contain multiple FileRoutes\r\nexport const ourFileRouter = {\r\n  // Define as many FileRoutes as you like, each with a unique routeSlug\r\n  imageUploader: f(\r\n    {\r\n      image: {\r\n        /**\r\n         * For full list of options and defaults, see the File Route API reference\r\n         * @see https://docs.uploadthing.com/file-routes#route-config\r\n         */\r\n        maxFileSize: \"8MB\",\r\n      },\r\n    },\r\n    // Await server data to be sent to the client inorder to mark the file as uploaded\r\n    { awaitServerData: true }\r\n  )\r\n    .middleware(async ({ req }) => {\r\n      await rateLimitMiddleware(req);\r\n\r\n      // Whatever is returned here is accessible in onUploadComplete as `metadata`\r\n      return {};\r\n    })\r\n    .onUploadComplete(async ({ metadata, file }) => {\r\n      console.log(\"file url\", file.ufsUrl);\r\n      console.log(\"metadata\", metadata);\r\n\r\n      // !!! Whatever is returned here is sent to the clientside `onClientUploadComplete` callback\r\n      return {};\r\n    }),\r\n} satisfies FileRouter;\r\n\r\nexport type OurFileRouter = typeof ourFileRouter;\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib\\uploadthingui-utils.ts",
      "content": "import { ExpandedRouteConfig, FileRouterInputKey } from \"@uploadthing/shared\";\r\n\r\nexport function getFileSizeFormatted(size: number) {\r\n  if (size < 1024) return `${size} B`;\r\n  if (size < 1024 * 1024) return `${(size / 1024).toFixed(0)} KB`;\r\n  if (size < 1024 * 1024 * 1024) return `${(size / 1024 / 1024).toFixed(1)} MB`;\r\n  return `${(size / 1024 / 1024 / 1024).toFixed(2)} GB`;\r\n}\r\n\r\n// Return the objects value\r\nexport function checkFileObjectKey({\r\n  str,\r\n  obj,\r\n}: {\r\n  str: FileRouterInputKey | undefined;\r\n  obj: ExpandedRouteConfig | undefined;\r\n}) {\r\n  if (!str || !obj) return null;\r\n\r\n  if (obj && typeof obj === \"object\" && obj.hasOwnProperty(str)) {\r\n    return obj[str];\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * @description A utility function that truncates the file name to a maximum number of characters.\r\n * @param {string} fileName - The file name to truncate.\r\n * @param {number} maxChars - The maximum number of characters to truncate the file name to. Default is 24.\r\n * @returns {string} The truncated file name.\r\n */\r\nexport function truncateFileName(fileName: string, maxChars?: number) {\r\n  if (fileName.length > 20) {\r\n    return `${fileName.slice(0, maxChars ?? 24)}...`;\r\n  }\r\n  return fileName;\r\n}\r\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "stores\\main.ts",
      "content": "import { toast } from \"sonner\";\r\nimport { create } from \"zustand\";\r\n\r\nexport type UTUIFile = {\r\n  file: File;\r\n  id: string;\r\n  status: \"uploading\" | \"uploaded\" | \"not started\" | \"error\";\r\n  error?: string;\r\n  createdAt: Date;\r\n};\r\n\r\ntype additionalDetails = {\r\n  maxFileCount?: number;\r\n  minFileCount?: number;\r\n};\r\n\r\ninterface FileStorageState {\r\n  instances: Record<string, UTUIFile[]>;\r\n  addFiles: (\r\n    instanceId: string,\r\n    files: UTUIFile[],\r\n    additionalDetails: additionalDetails\r\n  ) => void;\r\n  removeFiles: (instanceId: string, fileId: string) => void;\r\n  updateFile: (instanceId: string, file: UTUIFile) => void;\r\n  getFiles: (instanceId: string) => UTUIFile[];\r\n}\r\n\r\nconst defaultFileStorageState = {\r\n  instances: {},\r\n};\r\n\r\nexport const useFileStorageStore = create<FileStorageState>()((set, get) => ({\r\n  ...defaultFileStorageState,\r\n  // Takes an array of files and add them to the state for a specific instance\r\n  addFiles: (\r\n    instanceId: string,\r\n    files: UTUIFile[],\r\n    additionalDetails: additionalDetails\r\n  ) => {\r\n    if (\r\n      additionalDetails.maxFileCount &&\r\n      get().getFiles(instanceId).length + files.length >\r\n        additionalDetails.maxFileCount\r\n    ) {\r\n      toast.error(`Failed to upload!`, {\r\n        description: `Max file count of ${additionalDetails.maxFileCount} exceeded.`,\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => toast.dismiss(),\r\n        },\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (\r\n      additionalDetails.minFileCount &&\r\n      get().getFiles(instanceId).length + files.length <\r\n        additionalDetails.minFileCount\r\n    ) {\r\n      toast.error(`Failed to upload!`, {\r\n        description: `Required to upload at least ${additionalDetails.minFileCount} files.`,\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => toast.dismiss(),\r\n        },\r\n      });\r\n      return;\r\n    }\r\n    return set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: [...(state.instances[instanceId] || []), ...files],\r\n      },\r\n    }));\r\n  },\r\n  // Takes an array of files and remove them from the state for a specific instance\r\n  removeFiles: (instanceId: string, fileId: string) => {\r\n    return set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: (state.instances[instanceId] || []).filter(\r\n          (file) => file.id !== fileId\r\n        ),\r\n      },\r\n    }));\r\n  },\r\n  updateFile: (instanceId: string, file: UTUIFile) =>\r\n    set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: (state.instances[instanceId] || []).map((f) =>\r\n          f.id === file.id ? file : f\r\n        ),\r\n      },\r\n    })),\r\n  getFiles: (instanceId: string) => get().instances[instanceId] || [],\r\n}));\r\n",
      "type": "registry:component",
      "target": ""
    }
  ]
}