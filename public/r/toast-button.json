{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "toast-button",
  "type": "registry:component",
  "title": "Toast Button",
  "description": "An upload button component which uses toasts as its response method",
  "dependencies": [
    "lucide-react@^0.435.0",
    "@paralleldrive/cuid2@^2.2.2",
    "uploadthing@^7.7.2",
    "@uploadthing/react@^7.3.1",
    "@uploadthing/shared@^7.1.8",
    "@radix-ui/react-slot",
    "class-variance-authority",
    "clsx",
    "tailwind-merge",
    ".",
    "@uploadthing/react",
    "@uploadthing/shared",
    "sonner",
    "zustand",
    "@paralleldrive/cuid2",
    "lucide-react",
    "uploadthing"
  ],
  "registryDependencies": [
    "sonner",
    "button"
  ],
  "files": [
    {
      "path": "registry/new-york/toast-button/toast-button.tsx",
      "content": "\"use client\";\r\n\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { UploadButton, useUploadThing } from \"@/lib/uploadthing\";\r\nimport {\r\n  checkFileObjectKey,\r\n  getFileSizeFormatted,\r\n  truncateFileName,\r\n} from \"@/lib/uploadthingui-utils\";\r\nimport { useFileStorageStore, type UTUIFile } from \"@/stores/main\";\r\nimport { createId } from \"@paralleldrive/cuid2\";\r\nimport { Upload } from \"lucide-react\";\r\nimport { useEffect, useRef, type ComponentProps } from \"react\";\r\nimport { toast } from \"sonner\";\r\nimport { generatePermittedFileTypes } from \"uploadthing/client\";\r\n\r\n// Get the props type directly from UploadButton\r\ntype UploadButtonProps = ComponentProps<typeof UploadButton>;\r\n\r\n/**\r\n * @description An upload button component which uses toasts as its response method.\r\n * @param {UploadButtonProps} props - The props for the UploadButton component.\r\n * @param {boolean} showDetails - Whether to show the details of the upload.\r\n * @param {string} instanceId - The instance ID for the upload. Required to avoid multiple instances of the same component if multiple upload buttons are used.\r\n * @param {boolean} allowInBetweenUploads - Whether to allow in between uploads.\r\n * @param {routeDetails} routeDetails - Additional details for the upload; Example: maxFileCount, minFileCount, etc.\r\n * @param {React.ReactNode} children - React node to render a custom button component.\r\n */\r\nexport default function ToastButton({\r\n  props,\r\n  showDetails = false,\r\n  instanceId,\r\n  allowInBetweenUploads = true,\r\n  routeDetails,\r\n  children,\r\n}: {\r\n  props: UploadButtonProps;\r\n  showDetails?: boolean;\r\n  instanceId: string;\r\n  routeDetails?: {\r\n    maxFileCount?: number;\r\n    minFileCount?: number;\r\n  };\r\n  allowInBetweenUploads?: boolean;\r\n  children?: React.ReactNode;\r\n}) {\r\n  // [1]. States, Refs, Hooks, etc.\r\n  const { endpoint, ...restProps } = props;\r\n\r\n  // Used to reference the file input element\r\n  const fileInputRef = useRef<HTMLInputElement>(null);\r\n\r\n  const { getFiles, addFiles } = useFileStorageStore();\r\n\r\n  // Used to get the route config from uploadthing\r\n  const { routeConfig } = useUploadThing(endpoint, {\r\n    ...restProps,\r\n  });\r\n\r\n  const files = getFiles(instanceId);\r\n\r\n  const canUpload =\r\n    allowInBetweenUploads ||\r\n    files.filter((file) => file.status === \"uploading\").length === 0;\r\n\r\n  // Used to generate the accepted file types\r\n  const acceptedFileTypes = generatePermittedFileTypes(routeConfig)\r\n    .fileTypes.map((fileType) => {\r\n      if (fileType.includes(\"/\")) {\r\n        return fileType;\r\n      } else {\r\n        return `${fileType}/*`;\r\n      }\r\n    })\r\n    .join(\",\");\r\n\r\n  // Used to check the file route options\r\n  const fileRouteOptions = checkFileObjectKey({\r\n    str: generatePermittedFileTypes(routeConfig).fileTypes[0],\r\n    obj: routeConfig,\r\n  });\r\n\r\n  // If the file route options are not found then return\r\n  if (!fileRouteOptions) return;\r\n\r\n  // [2]. Handlers\r\n  // Used to open the file input prompt\r\n  const handleFileButtonClick = () => {\r\n    fileInputRef.current?.click();\r\n  };\r\n\r\n  // Used to handle the file change event\r\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const selectedFiles = e.target.files;\r\n\r\n    // If no files are selected then return\r\n    if (!selectedFiles || selectedFiles.length === 0) return;\r\n\r\n    if (!canUpload) return;\r\n\r\n    // At this moment, the files are not uploaded, so we set the status to \"not started\"\r\n    addFiles(\r\n      instanceId,\r\n      Array.from(selectedFiles).map((fileObj) => ({\r\n        id: createId(),\r\n        file: fileObj,\r\n        status: \"not started\",\r\n        createdAt: new Date(),\r\n      })),\r\n      routeDetails ?? {}\r\n    );\r\n\r\n    // Reset the input to allow selection of the same files again\r\n    if (fileInputRef.current) {\r\n      fileInputRef.current.value = \"\";\r\n    }\r\n  };\r\n\r\n  // [3]. JSX\r\n  return (\r\n    <>\r\n      {/* Hidden input to allow selection of files */}\r\n      <input\r\n        ref={fileInputRef}\r\n        type=\"file\"\r\n        className=\"hidden\"\r\n        multiple={\r\n          routeDetails?.maxFileCount === undefined ||\r\n          routeDetails.maxFileCount > 1\r\n        }\r\n        accept={acceptedFileTypes}\r\n        onChange={handleFileChange}\r\n      />\r\n      <div className=\"flex flex-col items-center gap-4\">\r\n        <ActionButton\r\n          children={children}\r\n          handleFileButtonClick={handleFileButtonClick}\r\n          disabled={!canUpload}\r\n        />\r\n        {showDetails && (\r\n          <ButtonDetails\r\n            acceptedFileTypes={acceptedFileTypes}\r\n            maxFileCount={routeDetails?.maxFileCount ?? 0}\r\n            minFileCount={routeDetails?.minFileCount ?? 0}\r\n            maxFileSize={fileRouteOptions.maxFileSize}\r\n          />\r\n        )}\r\n      </div>\r\n      {/* Uploading toasts */}\r\n      {files.map((file) => (\r\n        <UploadingToast\r\n          key={file.id}\r\n          file={file}\r\n          props={props}\r\n          instanceId={instanceId}\r\n        />\r\n      ))}\r\n    </>\r\n  );\r\n}\r\n\r\n/**\r\n * @description A component that displays the uploading toast.\r\n * @param {UTUIFile} file - The file to upload.\r\n * @param {UploadButtonProps} props - The props for the UploadButton component.\r\n * @param {string} instanceId - The instance ID for the upload. Required to avoid multiple instances of the same component if multiple upload buttons are used.\r\n */\r\nfunction UploadingToast({\r\n  file,\r\n  props,\r\n  instanceId,\r\n}: {\r\n  file: UTUIFile;\r\n  props: UploadButtonProps;\r\n  instanceId: string;\r\n}) {\r\n  // [1]. States, Refs, Hooks, etc.\r\n  const { endpoint, ...restProps } = props;\r\n\r\n  const fileUploadRef = useRef(false);\r\n\r\n  // Used to create an abort controller\r\n  const abortControllerRef = useRef<AbortController | null>(\r\n    new AbortController()\r\n  );\r\n\r\n  const { removeFiles, updateFile, getFiles } = useFileStorageStore();\r\n\r\n  // Used to start the upload\r\n  const { startUpload } = useUploadThing(endpoint, {\r\n    ...restProps,\r\n    // Set the upload progress granularity to \"fine\" if not provided\r\n    uploadProgressGranularity: restProps.uploadProgressGranularity ?? \"fine\",\r\n    signal: abortControllerRef.current?.signal,\r\n    onUploadError: (error) => {\r\n      // Run the onUploadError prop if provided\r\n      restProps.onUploadError?.(error);\r\n\r\n      // Update the file status to \"error\" and set the error message\r\n      updateFile(instanceId, {\r\n        ...file,\r\n        status: \"error\",\r\n        error: error.message,\r\n      });\r\n\r\n      // Throw the error to be caught by the toast\r\n      throw new Error(error.message);\r\n    },\r\n    onBeforeUploadBegin: (files) => {\r\n      // Run the onUploadBegin prop if provided\r\n      restProps?.onUploadBegin?.(file.file.name);\r\n\r\n      // Update the file status to \"uploading\"\r\n      updateFile(instanceId, { ...file, status: \"uploading\" });\r\n\r\n      return files;\r\n    },\r\n    onClientUploadComplete: (res) => {\r\n      // Run the onClientUploadComplete prop if provided\r\n      restProps?.onClientUploadComplete?.(res);\r\n\r\n      // Update the file status to \"uploaded\"\r\n      updateFile(instanceId, { ...file, status: \"uploaded\" });\r\n    },\r\n  });\r\n\r\n  // [2]. Effects\r\n  // This effect will only then start the upload to avoid rerendering / reuploading the same files\r\n  useEffect(() => {\r\n    if (!fileUploadRef.current && file.status === \"not started\") {\r\n      // Set the file upload ref to true to avoid reuploading the same file\r\n      fileUploadRef.current = true;\r\n\r\n      // Start the upload\r\n      const fileUploadPromise = startUpload([file.file]);\r\n\r\n      // Render the toast\r\n      toast.promise(fileUploadPromise, {\r\n        loading: (\r\n          <div className=\"flex flex-col\">\r\n            <p>Uploading...</p>\r\n            <p>\r\n              {truncateFileName(file.file.name)} (\r\n              {getFileSizeFormatted(file.file.size)})\r\n            </p>\r\n          </div>\r\n        ),\r\n        success: () => {\r\n          // Remove the file from the state to avoid reuploading the same file\r\n          removeFiles(instanceId, file.id);\r\n\r\n          return {\r\n            message: `Uploaded successfully!`,\r\n            description: `${truncateFileName(\r\n              file.file.name\r\n            )} - (${getFileSizeFormatted(file.file.size)})`,\r\n          };\r\n        },\r\n        error: () => {\r\n          const currentFile = getFiles(instanceId).find(\r\n            (f) => f.id === file.id\r\n          );\r\n\r\n          // Remove the file from the state to avoid reuploading the same file\r\n          removeFiles(instanceId, file.id);\r\n\r\n          return {\r\n            message: `${currentFile?.error\r\n              ? truncateFileName(currentFile.error, 32)\r\n              : \"Failed to upload!\"\r\n              }`,\r\n            description: `${truncateFileName(\r\n              file.file.name\r\n            )} - (${getFileSizeFormatted(file.file.size)})`,\r\n          };\r\n        },\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => {\r\n            // Remove the file and abort the upload\r\n            abortControllerRef.current?.abort();\r\n            removeFiles(instanceId, file.id);\r\n          },\r\n        },\r\n      });\r\n    }\r\n  }, [file]);\r\n\r\n  // Returning null because the toast is rendered by the useUploadThing hook\r\n  return null;\r\n}\r\n\r\n/**\r\n * @description A conditional button component that will render a custom button component if provided, otherwise it will render a default button component.\r\n * @param {function} handleFileButtonClick - Function to handle the file button click event.\r\n * @param {boolean} disabled - Whether to disable the button.\r\n * @param {React.ReactNode} children - React node to render a custom button component.\r\n */\r\nfunction ActionButton({\r\n  handleFileButtonClick,\r\n  disabled,\r\n  children,\r\n}: {\r\n  handleFileButtonClick: () => void;\r\n  disabled?: boolean;\r\n  children: React.ReactNode;\r\n}) {\r\n  // If a custom button has returned then render that and attach the onClick handler to it\r\n  if (children) {\r\n    return <div onClick={handleFileButtonClick}>{children}</div>;\r\n  }\r\n\r\n  // Otherwise render the default button component\r\n  return (\r\n    <Button\r\n      className=\"w-fit\"\r\n      onClick={handleFileButtonClick}\r\n      disabled={disabled}\r\n    >\r\n      <Upload className=\"w-4 h-4\" />\r\n      <span className=\"ml-2\">Upload</span>\r\n    </Button>\r\n  );\r\n}\r\n\r\n/**\r\n * @description A component that displays the details of the upload button.\r\n * @param {string} acceptedFileTypes - The accepted file types.\r\n * @param {number} maxFileCount - The maximum number of files that can be uploaded.\r\n * @param {string} maxFileSize - The maximum file size that can be uploaded.\r\n */\r\nfunction ButtonDetails({\r\n  acceptedFileTypes,\r\n  maxFileCount,\r\n  maxFileSize,\r\n  minFileCount,\r\n}: {\r\n  acceptedFileTypes: string;\r\n  maxFileCount: number;\r\n  maxFileSize: string;\r\n  minFileCount: number;\r\n}) {\r\n  // [1]. JSX\r\n  return (\r\n    <div className=\"flex gap-2 flex-wrap items-center justify-center text-sm\">\r\n      <span className=\"text-center\">Allowed type: {acceptedFileTypes}</span>\r\n      <span className=\"text-center\">\r\n        Atleast {minFileCount > 1 ? minFileCount : 1} file(s)\r\n      </span>\r\n      {maxFileCount > 0 && (\r\n        <span className=\"text-center\">Atmost {maxFileCount} file(s)</span>\r\n      )}\r\n      <span className=\"text-center\">Up to {maxFileSize} each</span>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "components/uploadthingui/toast-button.tsx"
    },
    {
      "path": "stores/main.ts",
      "content": "import { toast } from \"sonner\";\r\nimport { create } from \"zustand\";\r\n\r\nexport type UTUIFile = {\r\n  file: File;\r\n  id: string;\r\n  status: \"uploading\" | \"uploaded\" | \"not started\" | \"error\";\r\n  error?: string;\r\n  createdAt: Date;\r\n};\r\n\r\ntype additionalDetails = {\r\n  maxFileCount?: number;\r\n  minFileCount?: number;\r\n};\r\n\r\ninterface FileStorageState {\r\n  instances: Record<string, UTUIFile[]>;\r\n  addFiles: (\r\n    instanceId: string,\r\n    files: UTUIFile[],\r\n    additionalDetails: additionalDetails\r\n  ) => void;\r\n  removeFiles: (instanceId: string, fileId: string) => void;\r\n  updateFile: (instanceId: string, file: UTUIFile) => void;\r\n  getFiles: (instanceId: string) => UTUIFile[];\r\n}\r\n\r\nconst defaultFileStorageState = {\r\n  instances: {},\r\n};\r\n\r\nexport const useFileStorageStore = create<FileStorageState>()((set, get) => ({\r\n  ...defaultFileStorageState,\r\n  // Takes an array of files and add them to the state for a specific instance\r\n  addFiles: (\r\n    instanceId: string,\r\n    files: UTUIFile[],\r\n    additionalDetails: additionalDetails\r\n  ) => {\r\n    if (\r\n      additionalDetails.maxFileCount &&\r\n      get().getFiles(instanceId).length + files.length >\r\n        additionalDetails.maxFileCount\r\n    ) {\r\n      toast.error(`Failed to upload!`, {\r\n        description: `Max file count of ${additionalDetails.maxFileCount} exceeded.`,\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => toast.dismiss(),\r\n        },\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (\r\n      additionalDetails.minFileCount &&\r\n      get().getFiles(instanceId).length + files.length <\r\n        additionalDetails.minFileCount\r\n    ) {\r\n      toast.error(`Failed to upload!`, {\r\n        description: `Required to upload at least ${additionalDetails.minFileCount} files.`,\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => toast.dismiss(),\r\n        },\r\n      });\r\n      return;\r\n    }\r\n    return set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: [...(state.instances[instanceId] || []), ...files],\r\n      },\r\n    }));\r\n  },\r\n  // Takes an array of files and remove them from the state for a specific instance\r\n  removeFiles: (instanceId: string, fileId: string) => {\r\n    return set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: (state.instances[instanceId] || []).filter(\r\n          (file) => file.id !== fileId\r\n        ),\r\n      },\r\n    }));\r\n  },\r\n  updateFile: (instanceId: string, file: UTUIFile) =>\r\n    set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: (state.instances[instanceId] || []).map((f) =>\r\n          f.id === file.id ? file : f\r\n        ),\r\n      },\r\n    })),\r\n  getFiles: (instanceId: string) => get().instances[instanceId] || [],\r\n}));\r\n",
      "type": "registry:file",
      "target": "stores/main.ts"
    },
    {
      "path": "lib/uploadthingui-utils.ts",
      "content": "import { type ExpandedRouteConfig, type FileRouterInputKey } from \"@uploadthing/shared\";\r\n\r\nexport function getFileSizeFormatted(size: number) {\r\n  if (size < 1024) return `${size} B`;\r\n  if (size < 1024 * 1024) return `${(size / 1024).toFixed(0)} KB`;\r\n  if (size < 1024 * 1024 * 1024) return `${(size / 1024 / 1024).toFixed(1)} MB`;\r\n  return `${(size / 1024 / 1024 / 1024).toFixed(2)} GB`;\r\n}\r\n\r\n// Return the objects value\r\nexport function checkFileObjectKey({\r\n  str,\r\n  obj,\r\n}: {\r\n  str: FileRouterInputKey | undefined;\r\n  obj: ExpandedRouteConfig | undefined;\r\n}) {\r\n  if (!str || !obj) return null;\r\n\r\n  if (obj && typeof obj === \"object\" && obj.hasOwnProperty(str)) {\r\n    return obj[str];\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * @description A utility function that truncates the file name to a maximum number of characters.\r\n * @param {string} fileName - The file name to truncate.\r\n * @param {number} maxChars - The maximum number of characters to truncate the file name to. Default is 24.\r\n * @returns {string} The truncated file name.\r\n */\r\nexport function truncateFileName(fileName: string, maxChars?: number) {\r\n  if (fileName.length > 20) {\r\n    return `${fileName.slice(0, maxChars ?? 24)}...`;\r\n  }\r\n  return fileName;\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/uploadthing.ts",
      "content": "import {\r\n  generateUploadButton,\r\n  generateUploadDropzone,\r\n  generateReactHelpers,\r\n} from \"@uploadthing/react\";\r\nimport { type OurFileRouter } from \"./uploadthingui-types\";\r\n\r\nexport const UploadButton = generateUploadButton<OurFileRouter>();\r\nexport const UploadDropzone = generateUploadDropzone<OurFileRouter>();\r\nexport const { useUploadThing, uploadFiles } = generateReactHelpers<OurFileRouter>();\r\n\r\n// Export a type that users can extend if needed\r\nexport type FileRouter = OurFileRouter;",
      "type": "registry:lib"
    },
    {
      "path": "lib/uploadthingui-types.ts",
      "content": "import { type FileRouter } from \"uploadthing/next\";\r\n\r\n// Export a basic FileRouter type that users can extend\r\nexport type OurFileRouter = FileRouter;",
      "type": "registry:lib"
    },
    {
      "path": "registry\\new-york\\toast-button\\toast-button.tsx",
      "content": "\"use client\";\r\n\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { UploadButton, useUploadThing } from \"@/lib/uploadthing\";\r\nimport {\r\n  checkFileObjectKey,\r\n  getFileSizeFormatted,\r\n  truncateFileName,\r\n} from \"@/lib/uploadthingui-utils\";\r\nimport { useFileStorageStore, type UTUIFile } from \"@/stores/main\";\r\nimport { createId } from \"@paralleldrive/cuid2\";\r\nimport { Upload } from \"lucide-react\";\r\nimport { useEffect, useRef, type ComponentProps } from \"react\";\r\nimport { toast } from \"sonner\";\r\nimport { generatePermittedFileTypes } from \"uploadthing/client\";\r\n\r\n// Get the props type directly from UploadButton\r\ntype UploadButtonProps = ComponentProps<typeof UploadButton>;\r\n\r\n/**\r\n * @description An upload button component which uses toasts as its response method.\r\n * @param {UploadButtonProps} props - The props for the UploadButton component.\r\n * @param {boolean} showDetails - Whether to show the details of the upload.\r\n * @param {string} instanceId - The instance ID for the upload. Required to avoid multiple instances of the same component if multiple upload buttons are used.\r\n * @param {boolean} allowInBetweenUploads - Whether to allow in between uploads.\r\n * @param {routeDetails} routeDetails - Additional details for the upload; Example: maxFileCount, minFileCount, etc.\r\n * @param {React.ReactNode} children - React node to render a custom button component.\r\n */\r\nexport default function ToastButton({\r\n  props,\r\n  showDetails = false,\r\n  instanceId,\r\n  allowInBetweenUploads = true,\r\n  routeDetails,\r\n  children,\r\n}: {\r\n  props: UploadButtonProps;\r\n  showDetails?: boolean;\r\n  instanceId: string;\r\n  routeDetails?: {\r\n    maxFileCount?: number;\r\n    minFileCount?: number;\r\n  };\r\n  allowInBetweenUploads?: boolean;\r\n  children?: React.ReactNode;\r\n}) {\r\n  // [1]. States, Refs, Hooks, etc.\r\n  const { endpoint, ...restProps } = props;\r\n\r\n  // Used to reference the file input element\r\n  const fileInputRef = useRef<HTMLInputElement>(null);\r\n\r\n  const { getFiles, addFiles } = useFileStorageStore();\r\n\r\n  // Used to get the route config from uploadthing\r\n  const { routeConfig } = useUploadThing(endpoint, {\r\n    ...restProps,\r\n  });\r\n\r\n  const files = getFiles(instanceId);\r\n\r\n  const canUpload =\r\n    allowInBetweenUploads ||\r\n    files.filter((file) => file.status === \"uploading\").length === 0;\r\n\r\n  // Used to generate the accepted file types\r\n  const acceptedFileTypes = generatePermittedFileTypes(routeConfig)\r\n    .fileTypes.map((fileType) => {\r\n      if (fileType.includes(\"/\")) {\r\n        return fileType;\r\n      } else {\r\n        return `${fileType}/*`;\r\n      }\r\n    })\r\n    .join(\",\");\r\n\r\n  // Used to check the file route options\r\n  const fileRouteOptions = checkFileObjectKey({\r\n    str: generatePermittedFileTypes(routeConfig).fileTypes[0],\r\n    obj: routeConfig,\r\n  });\r\n\r\n  // If the file route options are not found then return\r\n  if (!fileRouteOptions) return;\r\n\r\n  // [2]. Handlers\r\n  // Used to open the file input prompt\r\n  const handleFileButtonClick = () => {\r\n    fileInputRef.current?.click();\r\n  };\r\n\r\n  // Used to handle the file change event\r\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const selectedFiles = e.target.files;\r\n\r\n    // If no files are selected then return\r\n    if (!selectedFiles || selectedFiles.length === 0) return;\r\n\r\n    if (!canUpload) return;\r\n\r\n    // At this moment, the files are not uploaded, so we set the status to \"not started\"\r\n    addFiles(\r\n      instanceId,\r\n      Array.from(selectedFiles).map((fileObj) => ({\r\n        id: createId(),\r\n        file: fileObj,\r\n        status: \"not started\",\r\n        createdAt: new Date(),\r\n      })),\r\n      routeDetails ?? {}\r\n    );\r\n\r\n    // Reset the input to allow selection of the same files again\r\n    if (fileInputRef.current) {\r\n      fileInputRef.current.value = \"\";\r\n    }\r\n  };\r\n\r\n  // [3]. JSX\r\n  return (\r\n    <>\r\n      {/* Hidden input to allow selection of files */}\r\n      <input\r\n        ref={fileInputRef}\r\n        type=\"file\"\r\n        className=\"hidden\"\r\n        multiple={\r\n          routeDetails?.maxFileCount === undefined ||\r\n          routeDetails.maxFileCount > 1\r\n        }\r\n        accept={acceptedFileTypes}\r\n        onChange={handleFileChange}\r\n      />\r\n      <div className=\"flex flex-col items-center gap-4\">\r\n        <ActionButton\r\n          children={children}\r\n          handleFileButtonClick={handleFileButtonClick}\r\n          disabled={!canUpload}\r\n        />\r\n        {showDetails && (\r\n          <ButtonDetails\r\n            acceptedFileTypes={acceptedFileTypes}\r\n            maxFileCount={routeDetails?.maxFileCount ?? 0}\r\n            minFileCount={routeDetails?.minFileCount ?? 0}\r\n            maxFileSize={fileRouteOptions.maxFileSize}\r\n          />\r\n        )}\r\n      </div>\r\n      {/* Uploading toasts */}\r\n      {files.map((file) => (\r\n        <UploadingToast\r\n          key={file.id}\r\n          file={file}\r\n          props={props}\r\n          instanceId={instanceId}\r\n        />\r\n      ))}\r\n    </>\r\n  );\r\n}\r\n\r\n/**\r\n * @description A component that displays the uploading toast.\r\n * @param {UTUIFile} file - The file to upload.\r\n * @param {UploadButtonProps} props - The props for the UploadButton component.\r\n * @param {string} instanceId - The instance ID for the upload. Required to avoid multiple instances of the same component if multiple upload buttons are used.\r\n */\r\nfunction UploadingToast({\r\n  file,\r\n  props,\r\n  instanceId,\r\n}: {\r\n  file: UTUIFile;\r\n  props: UploadButtonProps;\r\n  instanceId: string;\r\n}) {\r\n  // [1]. States, Refs, Hooks, etc.\r\n  const { endpoint, ...restProps } = props;\r\n\r\n  const fileUploadRef = useRef(false);\r\n\r\n  // Used to create an abort controller\r\n  const abortControllerRef = useRef<AbortController | null>(\r\n    new AbortController()\r\n  );\r\n\r\n  const { removeFiles, updateFile, getFiles } = useFileStorageStore();\r\n\r\n  // Used to start the upload\r\n  const { startUpload } = useUploadThing(endpoint, {\r\n    ...restProps,\r\n    // Set the upload progress granularity to \"fine\" if not provided\r\n    uploadProgressGranularity: restProps.uploadProgressGranularity ?? \"fine\",\r\n    signal: abortControllerRef.current?.signal,\r\n    onUploadError: (error) => {\r\n      // Run the onUploadError prop if provided\r\n      restProps.onUploadError?.(error);\r\n\r\n      // Update the file status to \"error\" and set the error message\r\n      updateFile(instanceId, {\r\n        ...file,\r\n        status: \"error\",\r\n        error: error.message,\r\n      });\r\n\r\n      // Throw the error to be caught by the toast\r\n      throw new Error(error.message);\r\n    },\r\n    onBeforeUploadBegin: (files) => {\r\n      // Run the onUploadBegin prop if provided\r\n      restProps?.onUploadBegin?.(file.file.name);\r\n\r\n      // Update the file status to \"uploading\"\r\n      updateFile(instanceId, { ...file, status: \"uploading\" });\r\n\r\n      return files;\r\n    },\r\n    onClientUploadComplete: (res) => {\r\n      // Run the onClientUploadComplete prop if provided\r\n      restProps?.onClientUploadComplete?.(res);\r\n\r\n      // Update the file status to \"uploaded\"\r\n      updateFile(instanceId, { ...file, status: \"uploaded\" });\r\n    },\r\n  });\r\n\r\n  // [2]. Effects\r\n  // This effect will only then start the upload to avoid rerendering / reuploading the same files\r\n  useEffect(() => {\r\n    if (!fileUploadRef.current && file.status === \"not started\") {\r\n      // Set the file upload ref to true to avoid reuploading the same file\r\n      fileUploadRef.current = true;\r\n\r\n      // Start the upload\r\n      const fileUploadPromise = startUpload([file.file]);\r\n\r\n      // Render the toast\r\n      toast.promise(fileUploadPromise, {\r\n        loading: (\r\n          <div className=\"flex flex-col\">\r\n            <p>Uploading...</p>\r\n            <p>\r\n              {truncateFileName(file.file.name)} (\r\n              {getFileSizeFormatted(file.file.size)})\r\n            </p>\r\n          </div>\r\n        ),\r\n        success: () => {\r\n          // Remove the file from the state to avoid reuploading the same file\r\n          removeFiles(instanceId, file.id);\r\n\r\n          return {\r\n            message: `Uploaded successfully!`,\r\n            description: `${truncateFileName(\r\n              file.file.name\r\n            )} - (${getFileSizeFormatted(file.file.size)})`,\r\n          };\r\n        },\r\n        error: () => {\r\n          const currentFile = getFiles(instanceId).find(\r\n            (f) => f.id === file.id\r\n          );\r\n\r\n          // Remove the file from the state to avoid reuploading the same file\r\n          removeFiles(instanceId, file.id);\r\n\r\n          return {\r\n            message: `${currentFile?.error\r\n              ? truncateFileName(currentFile.error, 32)\r\n              : \"Failed to upload!\"\r\n              }`,\r\n            description: `${truncateFileName(\r\n              file.file.name\r\n            )} - (${getFileSizeFormatted(file.file.size)})`,\r\n          };\r\n        },\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => {\r\n            // Remove the file and abort the upload\r\n            abortControllerRef.current?.abort();\r\n            removeFiles(instanceId, file.id);\r\n          },\r\n        },\r\n      });\r\n    }\r\n  }, [file]);\r\n\r\n  // Returning null because the toast is rendered by the useUploadThing hook\r\n  return null;\r\n}\r\n\r\n/**\r\n * @description A conditional button component that will render a custom button component if provided, otherwise it will render a default button component.\r\n * @param {function} handleFileButtonClick - Function to handle the file button click event.\r\n * @param {boolean} disabled - Whether to disable the button.\r\n * @param {React.ReactNode} children - React node to render a custom button component.\r\n */\r\nfunction ActionButton({\r\n  handleFileButtonClick,\r\n  disabled,\r\n  children,\r\n}: {\r\n  handleFileButtonClick: () => void;\r\n  disabled?: boolean;\r\n  children: React.ReactNode;\r\n}) {\r\n  // If a custom button has returned then render that and attach the onClick handler to it\r\n  if (children) {\r\n    return <div onClick={handleFileButtonClick}>{children}</div>;\r\n  }\r\n\r\n  // Otherwise render the default button component\r\n  return (\r\n    <Button\r\n      className=\"w-fit\"\r\n      onClick={handleFileButtonClick}\r\n      disabled={disabled}\r\n    >\r\n      <Upload className=\"w-4 h-4\" />\r\n      <span className=\"ml-2\">Upload</span>\r\n    </Button>\r\n  );\r\n}\r\n\r\n/**\r\n * @description A component that displays the details of the upload button.\r\n * @param {string} acceptedFileTypes - The accepted file types.\r\n * @param {number} maxFileCount - The maximum number of files that can be uploaded.\r\n * @param {string} maxFileSize - The maximum file size that can be uploaded.\r\n */\r\nfunction ButtonDetails({\r\n  acceptedFileTypes,\r\n  maxFileCount,\r\n  maxFileSize,\r\n  minFileCount,\r\n}: {\r\n  acceptedFileTypes: string;\r\n  maxFileCount: number;\r\n  maxFileSize: string;\r\n  minFileCount: number;\r\n}) {\r\n  // [1]. JSX\r\n  return (\r\n    <div className=\"flex gap-2 flex-wrap items-center justify-center text-sm\">\r\n      <span className=\"text-center\">Allowed type: {acceptedFileTypes}</span>\r\n      <span className=\"text-center\">\r\n        Atleast {minFileCount > 1 ? minFileCount : 1} file(s)\r\n      </span>\r\n      {maxFileCount > 0 && (\r\n        <span className=\"text-center\">Atmost {maxFileCount} file(s)</span>\r\n      )}\r\n      <span className=\"text-center\">Up to {maxFileSize} each</span>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "components\\ui\\button.tsx",
      "content": "import * as React from \"react\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst buttonVariants = cva(\r\n  \"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\r\n        destructive:\r\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\r\n        outline:\r\n          \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\r\n        secondary:\r\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\r\n        link: \"text-primary underline-offset-4 hover:underline\",\r\n      },\r\n      size: {\r\n        default: \"h-10 px-4 py-2\",\r\n        sm: \"h-9 rounded-md px-3\",\r\n        lg: \"h-11 rounded-md px-8\",\r\n        icon: \"h-9 w-9\",\r\n        xs: \"h-7 rounded-md px-2\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n      size: \"default\",\r\n    },\r\n  }\r\n);\r\n\r\nexport interface ButtonProps\r\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\r\n    VariantProps<typeof buttonVariants> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\r\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\r\n    const Comp = asChild ? Slot : \"button\";\r\n    return (\r\n      <Comp\r\n        className={cn(buttonVariants({ variant, size, className }))}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    );\r\n  }\r\n);\r\nButton.displayName = \"Button\";\r\n\r\nexport { Button, buttonVariants };\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib\\utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\";\r\nimport { twMerge } from \"tailwind-merge\";\r\nimport { EachRoute, ROUTES } from \"./routes-config\";\r\n\r\nexport function cn(...inputs: ClassValue[]) {\r\n  return twMerge(clsx(inputs));\r\n}\r\n\r\nexport function helperSearch(\r\n  query: string,\r\n  node: EachRoute,\r\n  prefix: string,\r\n  currenLevel: number,\r\n  maxLevel?: number\r\n) {\r\n  const res: EachRoute[] = [];\r\n  let parentHas = false;\r\n\r\n  const nextLink = `${prefix}${node.href}`;\r\n  if (!node.noLink && node.title.toLowerCase().includes(query.toLowerCase())) {\r\n    res.push({ ...node, items: undefined, href: nextLink });\r\n    parentHas = true;\r\n  }\r\n  const goNext = maxLevel ? currenLevel < maxLevel : true;\r\n  if (goNext) {\r\n    node.items?.forEach((item) => {\r\n      const innerRes = helperSearch(\r\n        query,\r\n        item,\r\n        nextLink,\r\n        currenLevel + 1,\r\n        maxLevel\r\n      );\r\n      if (!!innerRes.length && !parentHas && !node.noLink) {\r\n        res.push({ ...node, items: undefined, href: nextLink });\r\n        parentHas = true;\r\n      }\r\n      res.push(...innerRes);\r\n    });\r\n  }\r\n  return res;\r\n}\r\n\r\nexport function advanceSearch(query: string) {\r\n  return ROUTES.map((node) =>\r\n    helperSearch(query, node, \"\", 1, query.length == 0 ? 2 : undefined)\r\n  ).flat();\r\n}\r\n\r\n// Thursday, May 23, 2024\r\nexport function formatDate(dateStr: string): string {\r\n  const [day, month, year] = dateStr.split(\"-\").map(Number);\r\n  const date = new Date(year, month - 1, day);\r\n\r\n  const options: Intl.DateTimeFormatOptions = {\r\n    weekday: \"long\",\r\n    year: \"numeric\",\r\n    month: \"long\",\r\n    day: \"numeric\",\r\n  };\r\n\r\n  return date.toLocaleDateString(\"en-US\", options);\r\n}\r\n\r\n//  May 23, 2024\r\nexport function formatDate2(dateStr: string): string {\r\n  const [day, month, year] = dateStr.split(\"-\").map(Number);\r\n  const date = new Date(year, month - 1, day);\r\n\r\n  const options: Intl.DateTimeFormatOptions = {\r\n    month: \"short\",\r\n    day: \"numeric\",\r\n    year: \"numeric\",\r\n  };\r\n  return date.toLocaleDateString(\"en-US\", options);\r\n}\r\n\r\nexport function stringToDate(date: string) {\r\n  const [day, month, year] = date.split(\"-\").map(Number);\r\n  return new Date(year, month - 1, day);\r\n}\r\n\r\n// https://devicon.dev/\r\n//  icon format : <i class=\"devicon-go-plain\"></i>\r\nexport const fileExtensionIconMap = {\r\n  js: \"javascript\",\r\n  ts: \"typescript\",\r\n  jsx: \"react\",\r\n  tsx: \"react\",\r\n  java: \"java\",\r\n  css: \"css3\",\r\n  md: \"markdown\",\r\n  mdx: \"markdown\",\r\n  go: \"go\",\r\n  astro: \"astro\",\r\n  prisma: \"prisma\",\r\n  py: \"python\",\r\n  kt: \"kotlin\",\r\n  php: \"php\",\r\n  gitignore: \"git\",\r\n  cs: \"csharp\",\r\n  cpp: \"cplusplus\",\r\n  c: \"c\",\r\n  bash: \"bash\",\r\n  html: \"html5\",\r\n};\r\n\r\nexport function hasSupportedExtension(name: string) {\r\n  const splittedNames = name.split(\".\");\r\n  const ext = splittedNames[splittedNames.length - 1];\r\n  if (!ext) return false;\r\n  return !!fileExtensionIconMap[ext as keyof typeof fileExtensionIconMap];\r\n}\r\n\r\nexport function getIconName(name: string) {\r\n  const splittedNames = name.split(\".\");\r\n  const ext = splittedNames[splittedNames.length - 1];\r\n  return fileExtensionIconMap[ext as keyof typeof fileExtensionIconMap];\r\n}\r\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "lib\\uploadthing.ts",
      "content": "import {\r\n  generateUploadButton,\r\n  generateUploadDropzone,\r\n  generateReactHelpers,\r\n} from \"@uploadthing/react\";\r\nimport { type OurFileRouter } from \"./uploadthingui-types\";\r\n\r\nexport const UploadButton = generateUploadButton<OurFileRouter>();\r\nexport const UploadDropzone = generateUploadDropzone<OurFileRouter>();\r\nexport const { useUploadThing, uploadFiles } = generateReactHelpers<OurFileRouter>();\r\n\r\n// Export a type that users can extend if needed\r\nexport type FileRouter = OurFileRouter;",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "lib\\uploadthingui-utils.ts",
      "content": "import { type ExpandedRouteConfig, type FileRouterInputKey } from \"@uploadthing/shared\";\r\n\r\nexport function getFileSizeFormatted(size: number) {\r\n  if (size < 1024) return `${size} B`;\r\n  if (size < 1024 * 1024) return `${(size / 1024).toFixed(0)} KB`;\r\n  if (size < 1024 * 1024 * 1024) return `${(size / 1024 / 1024).toFixed(1)} MB`;\r\n  return `${(size / 1024 / 1024 / 1024).toFixed(2)} GB`;\r\n}\r\n\r\n// Return the objects value\r\nexport function checkFileObjectKey({\r\n  str,\r\n  obj,\r\n}: {\r\n  str: FileRouterInputKey | undefined;\r\n  obj: ExpandedRouteConfig | undefined;\r\n}) {\r\n  if (!str || !obj) return null;\r\n\r\n  if (obj && typeof obj === \"object\" && obj.hasOwnProperty(str)) {\r\n    return obj[str];\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * @description A utility function that truncates the file name to a maximum number of characters.\r\n * @param {string} fileName - The file name to truncate.\r\n * @param {number} maxChars - The maximum number of characters to truncate the file name to. Default is 24.\r\n * @returns {string} The truncated file name.\r\n */\r\nexport function truncateFileName(fileName: string, maxChars?: number) {\r\n  if (fileName.length > 20) {\r\n    return `${fileName.slice(0, maxChars ?? 24)}...`;\r\n  }\r\n  return fileName;\r\n}\r\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "stores\\main.ts",
      "content": "import { toast } from \"sonner\";\r\nimport { create } from \"zustand\";\r\n\r\nexport type UTUIFile = {\r\n  file: File;\r\n  id: string;\r\n  status: \"uploading\" | \"uploaded\" | \"not started\" | \"error\";\r\n  error?: string;\r\n  createdAt: Date;\r\n};\r\n\r\ntype additionalDetails = {\r\n  maxFileCount?: number;\r\n  minFileCount?: number;\r\n};\r\n\r\ninterface FileStorageState {\r\n  instances: Record<string, UTUIFile[]>;\r\n  addFiles: (\r\n    instanceId: string,\r\n    files: UTUIFile[],\r\n    additionalDetails: additionalDetails\r\n  ) => void;\r\n  removeFiles: (instanceId: string, fileId: string) => void;\r\n  updateFile: (instanceId: string, file: UTUIFile) => void;\r\n  getFiles: (instanceId: string) => UTUIFile[];\r\n}\r\n\r\nconst defaultFileStorageState = {\r\n  instances: {},\r\n};\r\n\r\nexport const useFileStorageStore = create<FileStorageState>()((set, get) => ({\r\n  ...defaultFileStorageState,\r\n  // Takes an array of files and add them to the state for a specific instance\r\n  addFiles: (\r\n    instanceId: string,\r\n    files: UTUIFile[],\r\n    additionalDetails: additionalDetails\r\n  ) => {\r\n    if (\r\n      additionalDetails.maxFileCount &&\r\n      get().getFiles(instanceId).length + files.length >\r\n        additionalDetails.maxFileCount\r\n    ) {\r\n      toast.error(`Failed to upload!`, {\r\n        description: `Max file count of ${additionalDetails.maxFileCount} exceeded.`,\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => toast.dismiss(),\r\n        },\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (\r\n      additionalDetails.minFileCount &&\r\n      get().getFiles(instanceId).length + files.length <\r\n        additionalDetails.minFileCount\r\n    ) {\r\n      toast.error(`Failed to upload!`, {\r\n        description: `Required to upload at least ${additionalDetails.minFileCount} files.`,\r\n        action: {\r\n          label: `Close`,\r\n          onClick: () => toast.dismiss(),\r\n        },\r\n      });\r\n      return;\r\n    }\r\n    return set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: [...(state.instances[instanceId] || []), ...files],\r\n      },\r\n    }));\r\n  },\r\n  // Takes an array of files and remove them from the state for a specific instance\r\n  removeFiles: (instanceId: string, fileId: string) => {\r\n    return set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: (state.instances[instanceId] || []).filter(\r\n          (file) => file.id !== fileId\r\n        ),\r\n      },\r\n    }));\r\n  },\r\n  updateFile: (instanceId: string, file: UTUIFile) =>\r\n    set((state) => ({\r\n      instances: {\r\n        ...state.instances,\r\n        [instanceId]: (state.instances[instanceId] || []).map((f) =>\r\n          f.id === file.id ? file : f\r\n        ),\r\n      },\r\n    })),\r\n  getFiles: (instanceId: string) => get().instances[instanceId] || [],\r\n}));\r\n",
      "type": "registry:component",
      "target": ""
    }
  ]
}